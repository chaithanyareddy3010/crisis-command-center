import { supabase } from "@/integrations/supabase/client";
import { Incident, ChatMessage, DashboardStats, Technician } from "@/types";

/**
 * Submit a new incident
 */
export const submitIncident = async (incidentData: Partial<Incident>): Promise<Incident> => {
  const { data: { user } } = await supabase.auth.getUser();
  
  // Find best available technician by skill match
  const { data: technicians } = await supabase
    .from("technicians")
    .select("*")
    .eq("availability", "available")
    .eq("skill", incidentData.category || "other");

  const assignedTech = technicians?.[0];

  const { data, error } = await supabase
    .from("incidents")
    .insert({
      incident_id: "", // Will be auto-generated by trigger
      title: incidentData.title || "",
      description: incidentData.description || "",
      location: incidentData.location || "",
      category: incidentData.category || "other",
      priority: incidentData.priority || "medium",
      status: "open",
      assigned_technician: assignedTech?.name || null,
      assignment_reason: assignedTech
        ? `AI-selected based on skill match (${assignedTech.skill}) and availability`
        : "No available technician with matching skill",
      required_skill: incidentData.category,
      sop_steps: [
        "Initial assessment and safety check",
        "Identify root cause using diagnostic tools",
        "Apply standard troubleshooting procedures",
        "Implement solution or escalate if needed",
        "Verify resolution and document findings",
      ],
      created_by: user?.id || null,
    })
    .select()
    .single();

  if (error) throw error;
  return data as Incident;
};

/**
 * Get all incidents
 */
export const getIncidents = async (): Promise<Incident[]> => {
  const { data, error } = await supabase
    .from("incidents")
    .select("*")
    .order("created_at", { ascending: false });

  if (error) throw error;
  return (data || []) as Incident[];
};

/**
 * Get incident by ID (incident_id like INC001 or uuid)
 */
export const getIncidentById = async (id: string): Promise<Incident | null> => {
  // Try incident_id first, then uuid
  const { data, error } = await supabase
    .from("incidents")
    .select("*")
    .or(`incident_id.eq.${id},id.eq.${id}`)
    .maybeSingle();

  if (error) throw error;
  return data as Incident | null;
};

/**
 * Get all technicians
 */
export const getTechnicians = async (): Promise<Technician[]> => {
  const { data, error } = await supabase
    .from("technicians")
    .select("*")
    .order("name");

  if (error) throw error;
  return (data || []) as Technician[];
};

/**
 * Chat with AI agent (mock for now)
 */
export const chatWithAgent = async (message: string, conversationHistory: ChatMessage[]): Promise<string> => {
  await new Promise((resolve) => setTimeout(resolve, 1500));

  const responses = [
    "I've analyzed your request. Based on the incident details, I recommend escalating this to a senior technician with electrical expertise.",
    "The current status shows high-priority incidents. Would you like me to help prioritize them based on business impact?",
    "I've reviewed the SOP for this type of incident. The key steps include safety verification, diagnostic assessment, and targeted intervention.",
    "Based on historical data, similar incidents were resolved in an average of 2.5 hours. I can assign the most suitable technician now.",
    "I can help with that. Let me check the current workload of available technicians and suggest the best assignment.",
  ];

  return responses[Math.floor(Math.random() * responses.length)];
};

/**
 * Get dashboard statistics
 */
export const getDashboardStats = async (): Promise<DashboardStats> => {
  const [incidentsRes, techniciansRes] = await Promise.all([
    supabase.from("incidents").select("priority"),
    supabase.from("technicians").select("availability"),
  ]);

  const incidents = incidentsRes.data || [];
  const technicians = techniciansRes.data || [];

  return {
    totalIncidents: incidents.length,
    highPriorityIncidents: incidents.filter((i) => i.priority === "high").length,
    availableTechnicians: technicians.filter((t) => t.availability === "available").length,
    avgResolutionTime: "2.5 hrs",
  };
};
